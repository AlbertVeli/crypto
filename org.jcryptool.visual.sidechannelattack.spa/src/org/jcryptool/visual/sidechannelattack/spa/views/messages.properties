#Eclipse modern messages class
#Mon Oct 01 22:58:51 CEST 2012
Constants_0=Information:
Constants_1=Result:
Constants_10=Mode:
Constants_100=Input:
Constants_101=Note: the private key could be recovered\n through power trace analysis of the difference\n between two branches of condition statement\n (red marked \"if statement\"). The concrete\n process will be shown in visualized form on\n the right side. Following a SPA-resistant algo-\n rithm will be given in the last part.\n
Constants_102= (dec.)
Constants_103=
Constants_104=. highest bit = 
Constants_105=Final Result: 
Constants_106=Input:
Constants_107=;  Res: 1;
Constants_108=Res = Res\u00b2 mod n
Constants_109=Res = Res * c mod n
Constants_11=  private key(d): 
Constants_110=Modul n = p*q = 
Constants_111=Res = 
Constants_112=\u00b2 mod 
Constants_113= Note: the exponentiation operation in encryption\n and decryption functions (yellow marked) is\n normally realized with Square and Multiply\n algorithm, which is proved vulnerable to SPA.\n\n 1. Choose two distinct prime numbers p and q.\n\n 2. Compute the modulus n = p*q.\n\n 3. Compute the totient: phi(n) = (p-1)*(q-1).\n\n 4. Choose a public key 'e' coprime with phi(n).\n\n 5. Determine private key 'd': d*e \u2261 1 mod {phi(n)}.\n\n 6. Encryption function: c \u2261 me mod{n}.\n\n 7. Decryption function: m \u2261 cd mod{n}.
Constants_114=Simple Power Analysis against RSA
Constants_115=Ciphertext c =
Constants_116=Private Key d =
Constants_117=Q =
Constants_118=P =
Constants_119=Round Counter(left to right)
Constants_12=Result after Square
Constants_120=Result after Multiplication
Constants_121=  Ciphertext(c): 
Constants_122=  Binary: 
Constants_123=Process:
Constants_124=Output:
Constants_125=M: the trace of multiplication operation in Square and Multiply.\nS: the trace of squaring operation in Square and Multiply.\n\nNote: If the current digit is a '0', only a squaring operation will be carried out, while the current digit is a '1', besides the squaring a multiplication operation will be executed follows the squaring. Obviously shown in the diagram above, the power traces between squaring and multiplication operations are quite different. In the decryption process according to the power traces we can distinguish every bit of private key is a binary '0' or a '1'.\nIf the whole secret key digits can be read from the power traces, the RSA is vulnerable. Of course, it should be mentioned that in fact the secret key of RSA is at least 1024 bit long and to ensure the security, it is recommended that n be at least 2048 bits long. However, no matter how long the secret key is, if the power traces of some key operations are obviously distinct, the RSA based cryptograhic system is insecure and weak.
Constants_126=Execute
Constants_127=Reset input values
Constants_128=Module n =
Constants_129=Res\u2080 = Res\u00b2 mod n
Constants_13=Res\u2081 = Res\u2080 * c mod n
Constants_130=Res\u2080 = 
Constants_131=Res\u2081 = 
Constants_132=M: the trace of multiplication operation in Square and Multiply.\nS: the trace of squaring operation in Square and Multiply.\n\nNote: As the algorithm \"Square and Multiply Always\" shown above, the squaring and multiplication operations will be constantly executed in each loop, so it is difficult to read out the private key with SPA.\r\nAvoiding these types of conditional statements when implementing these algorithms can eliminate many SPA weaknesses. In algorithms which inherently assume this type of key dependent branching, it may not be possible to remove these statements completely. However, operations with large power characteristics ( e.g. multiplications ) can be moved outside of conditional branches to decrease the size of SPA characteristics. This strategy can be applied to the square-and-multiply algorithm as shown above. \r\nTechniques for resisting power analysis can be implemented at both the hardware and software levels. Countermeasures at the software level seem to be more desirable, from a commercial standpoint at least, since they can be implemented on existing architectures. However countermeasures in software level are always based on sacrifice of the execution performance and the algorithm efficiency. The Hardware countermeasures are generally more costly to implement, but they may be necessary depending on the required level of security.
Constants_133=Note: in the modified algorithm \"Square and Multiply Always\", no matter the current bit is '0' or '1', the multiplication operation will be always executed. So it is impossible to recover the private key through comparison of the difference between power traces. So this \"Square and Multiply Always\" algorithm is resistant to SPA. \n\n Process:\n    int Res = 1;  //Initial value: Res\r\n    for(int i = m; i>-1; i--)  {\r\n   Res_0 = Res2 mod n;       //\"Square\"\r\n   Res_1 = Res_0 * c mod n;  //\"Multiply\"\r\n    Res = Res_(bi)}
Constants_134=choose a number as private key d here
Constants_135=give an integer number in field [-2^31, 2^31-1] as ciphertext
Constants_136=Click this button to clear input frames and left table.
Constants_137=c\u1d48(mod n) =
Constants_138=the result R is the decrypted plaintext
Constants_139=determine the prime Q here
Constants_14=determine the prime P here
Constants_140=the module n here is the result of P*Q
Constants_141=Square and Multiply
Constants_142=Square and Multiply Always
Constants_143=Parameters:
Constants_144=
Constants_145=
Constants_146=
Constants_147=
Constants_148=
Constants_149=
Constants_15=
Constants_16=
Constants_17=
Constants_18=
Constants_19=
Constants_2=
Constants_20=
Constants_21=
Constants_22=
Constants_23=
Constants_24=
Constants_25=
Constants_26=
Constants_27=
Constants_28=
Constants_29=
Constants_3=
Constants_30=
Constants_31=
Constants_32=
Constants_33=
Constants_34=
Constants_35=
Constants_36=
Constants_37=
Constants_38=
Constants_39=
Constants_4=
Constants_40=
Constants_41=
Constants_42=
Constants_43=
Constants_44=
Constants_45=
Constants_46=
Constants_47=
Constants_48=
Constants_49=
Constants_5=
Constants_50=
Constants_51=
Constants_52=
Constants_53=
Constants_54=
Constants_55=
Constants_56=
Constants_57=
Constants_58=
Constants_59=
Constants_6=
Constants_60=
Constants_61=
Constants_62=
Constants_63=
Constants_64=
Constants_65=
Constants_66=
Constants_67=
Constants_68=
Constants_69=
Constants_7=
Constants_70=
Constants_71=
Constants_72=
Constants_73=
Constants_74=
Constants_75=
Constants_76=
Constants_77=
Constants_78=
Constants_79=
Constants_8=
Constants_80=
Constants_81=
Constants_82=
Constants_83=
Constants_84=
Constants_85=
Constants_86=
Constants_87=
Constants_88=
Constants_89=
Constants_9=
Constants_90=
Constants_91=
Constants_92=
Constants_93=
Constants_94=
Constants_95=
Constants_96=
Constants_97=
Constants_98=
Constants_99=
