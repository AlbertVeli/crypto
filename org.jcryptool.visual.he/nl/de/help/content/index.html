<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>

      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

	  <title>Homomorphe Verschl&uuml;sselung</title>
</head>

<body>
  <h1>Homomorphe Verschl&uuml;sselung</h1>

  <p>Diese Hilfe besteht aus drei Teilen, der <a href="#term">Begriffserkl&auml;rung</a>, einer <a href="#schemes">Erkl&auml;rung der Schemata</a> und einer <a href="#plugin">Plug-in-Benutzerhilfe</a>. </p>

  <h3 id="term">1) Begriffserkl&auml;rung</h3>

  <p>Eine homomorphe Verschl&uuml;sselung ist eine Verschl&uuml;sselung, die homomorphe Operationen auf dem Chiffrat erlaubt. Daf&uuml;r ist es nicht notwendig, das Chiffrat entschl&uuml;sseln zu k&ouml;nnen. Diese homomorphen Operationen sind die Addition und die Multiplikation. Werden die Operationen durchgef&uuml;hrt, ist dies &auml;quivalent zur Durchf&uuml;hrung derselben Operationen auf den Klartexten.<br/>
  Es existieren drei Typen von homomorphen Verschl&uuml;sselungsschemata, "<a href="#partial">partielle</a>", "<a href="#somewhat">somewhat</a>" und "<a href="#fully">voll-homomorphe</a>" Verschl&uuml;sselungsschemata. Die Unterschiede zwischen diesen Schemata werden im Folgenden erkl&auml;rt. <br/>
  Diese Visualisierung in JCT beinhaltet drei verschiedene Schemata, ein voll-homomorphes Verschl&uuml;sselungsschema von  <a href="#gh">Gentry und Halevi</a> und zwei partiell-homomorphe Verschl&uuml;sselungsschemata -- <a href="#rsa">RSA</a> und <a href="#paillier">Paillier</a>. </p>

  <h4 id="partial">a) Partielle homomorphe Verschl&uuml;sselung</h4>

  <p>Wenn ein Schema partiell-homomorph ist, dann ist es entweder m&ouml;glich Multiplikationen oder Additionen auf dem Chiffrat durchzuf&uuml;hren. Im Allgemeinen erlauben partiell-homomorphe  Schemata eine unbegrenzte Anzahl an durchf&uuml;hrbaren Operationen. </p>

  <h4 id="somewhat">b) Somewhat homomorphe Verschl&uuml;sselung</h4>

  <p>Ein somewhat homomorphes Verschl&uuml;sselungsschema erlaubt beide homomorphen Operationen auf dem Chiffrat, aber mit einer begrenzten Anzahl aufeinanderfolgender Operationen. Man k&ouml;nnte dies als einen Fehler, der bei jeder Operation eingebracht wird, interpretieren. Wenn dieser Fehler klein ist, kann das Schema immer noch korrekt das Chiffrat entschl&uuml;sseln. Werden aber viele Operationen durchgef&uuml;hrt, w&auml;chst dieser Fehler &uuml;ber die Fehlerkorrekturf&auml;higkeit des Schemas hinaus, was zu einer inkorrekten Entschl&uuml;sselung f&uuml;hrt. </p>

  <h4 id="fully">c) Voll-homomorphe Verschl&uuml;sselung</h4>

  <p>Voll-homomorphe Verschl&uuml;sselungsschemata erlauben die Durchf&uuml;hrung einer unbegrenzten Anzahl von beiden homomorphen Operationen. Dies h&auml;ngt eng mit den somewhat homomorphen Verschl&uuml;sselungsschemata zusammen. Zus&auml;tzlich zu den normalen Operationen erlaubt ein voll-homomorphes Schema die Auffrischung des Chiffrats, bei der der Fehler im Chiffrat reduziert wird, was zus&auml;tzliche Operationen erlaubt, ohne dass die Fehlerkorrekturf&auml;higkeit des Schemas &uuml;berschritten wird. </p>

  <h3 id="schemes">2) Erkl&auml;rung der Schemata</h3>

  <h4 id="rsa">a) RSA – Partiell-homomorphes Verschl&uuml;sselungsschema</h4>

  <p>RSA ist ein weit verbreitetes Public-Key-Kryptosystem, das die <b>Multiplikation</b> von Chiffraten erlaubt. Im Allgemeinen funktioniert es wie folgt (f&uuml;r weitere Informationen siehe <a href="http://en.wikipedia.org/wiki/RSA">http://en.wikipedia.org/wiki/RSA</a>): Man w&auml;hlt zwei große, verschiedene Primzahlen, p und q. Je gr&ouml;ßer diese Primzahlen gew&auml;hlt werden, desto gr&ouml;ßer ist die Sicherheit. Dann berechnet man das Produkt N der beiden Primzahlen. Als n&auml;chstes w&auml;hlt man einen &ouml;ffentlichen Exponenten, der teilerfremd zu (p-1)(q-1) ist. Die Teilerfremdheit sichert, dass die multiplikative Inverse zu e modulo (p-1)(q-1) existiert. Diese Inverse wird mit dem Euklidischen Algorithmus berechnet und mit d bezeichnet, d ist der private Exponent. Sind diese Berechnungen durchgef&uuml;hrt, kann das Schema verwendet werden. Der &ouml;ffentliche Schl&uuml;ssel besteht aus N und e, der private aus d. <br/>
  Ver- und Entschl&uuml;sseln von Zahlen mit RSA ist einfach. Um eine Zahl m zu verschl&uuml;sseln, wird c = m^e mod N berechnet. Um ein Chiffrat c zu entschl&uuml;sseln, berechnet man m' = c^d mod N = m^(e*d) mod N = m. <br/>
  Um zu zeigen, dass RSA partiell homomorph ist, nehmen wir zwei Zahlen m1 und m2, und ihre zugeh&ouml;rigen Chiffrate c1 und c2. Das Produkt m1*m2 kann homomorph berechnet werden, indem lediglich das Produkt der Chiffrate c1 und c2 gebildet wird. Entschl&uuml;sselt ergibt dies m1*m2; (c1*c2)^d mod N = (c1^d)*(c2^d) mod N = (m1^(e*d))*(m2^(e*d)) mod N = m1*m2. Es ist ersichtlich, dass man dies beliebig oft wiederholen kann. Die einzige Beschr&auml;nkung bei der Multiplikation ist, dass die Operatoren &lt; N sind. Aufgrund der Gr&ouml;ße von N ist dies, in der Praxis, kein Hindernis f&uuml;r eine sichere Verschl&uuml;sselung. Dieses Schema ist nur partiell-homomorph, da man nur Multiplikationen durchf&uuml;hren kann. </p>

  <h4 id="paillier">b) Paillier – Partiell-homomorphes Verschl&uuml;sselungsschema</h4>

  <p>Paillier ist ein Verschl&uuml;sselungsschema, das <b>Additionen</b> auf dem Chiffrat erlaubt. Im Allgemeinen funktioniert es wie folgt (f&uuml;r weitere Informationen siehe <a href="http://en.wikipedia.org/wiki/Paillier_cryptosystem">http://en.wikipedia.org/wiki/Paillier_cryptosystem</a>): Man w&auml;hlt zwei große Primzahlen p und q, so dass gilt: ggt(p*q,(p-1)(q-1)) = 1. Diese Eigenschaft gilt immer, wenn p und q dieselbe Bitl&auml;nge haben. Jetzt berechnet man N = p*q und l = kgV(p-1,q-1). Als n&auml;chstes w&auml;hlt man zuf&auml;llig eine ganze Zahl g zwischen 1 und N^2, wobei N die Ordnung von g teilt. Dann berechnet man mu = (L(g^l mod N^2))^(-1) mod N, wobei L(u)=(u-1)/N. Der &ouml;ffentliche Schl&uuml;ssel besteht aus N und g, der private aus l und mu. <br/>
  Um mit Paillier zu verschl&uuml;sseln, wird zun&auml;chst eine ganze Zahl m zwischen 1 und N gew&auml;hlt. Dann wird zuf&auml;llig eine invertierbare, ganze Zahl r zwischen 1 und N gew&auml;hlt, sowie c = (g^m)*(r^N) mod N^2 berechnet. Zum Entschl&uuml;sseln eines Chiffrats berechnet man einfach m = L(c^l mod N^2)*mu mod N. <br/>
  Um zu zeigen, dass Paillier partiell-homomorph ist, nehmen wir zwei Zahlen m1 und m2 und ihre zugeh&ouml;rigen Chiffrate c1 und c2. Die Summe m1+m2 wird homomorph berechnet, indem man die Chiffrate c1und c2 multipliziert. Dies ist die Entschl&uuml;sselung von m1+m2: c1*c2=(g^m1)*(rl^N)*(g^m2)*(r2^N) mod N^2=(g^(m1+m2))*(r^N) mod N^2, was nichts anderes als m1+m2 ist. Die Addition erfolgt modulo N (da g^N=1 mod N^2), aber aufgrund der Gr&ouml;ße von N ist dies, in der Praxis, kein Hindernis. </p>

  <h4 id="gh">c) Gentry und Halevi – Voll-homomorphes Verschl&uuml;sselungsschema</h4>

  <p>Das voll-homomorphe Verschl&uuml;sselungsschema von <a href="https://researcher.ibm.com/researcher/files/us-shaih/fhe-implementation.pdf">Gentry and Halevi</a> ist eine Variante des Schemas von <a href="http://www.info.unicaen.fr/M2-AMI/articles-2009-2010/smart.pdf">Smart and Vercauteren</a>, das wiederum eine Variante des Originalschemas von <a href="http://domino.research.ibm.com/comm/research_projects.nsf/pages/security.homoenc.html/$FILE/stocdhe.pdf">Gentry</a> ist. Eine vollst&auml;ndige Erkl&auml;rung des Schemas w&auml;re hier zu komplex und deshalb wird nur eine kurze Erkl&auml;rung zum Grundverst&auml;ndnis geliefert: Das Schema nutzt &uuml;berwiegend ideale Gitter auf einem Polynomring modulo f(x) = x^n +1, wobei n eine Potenz von 2 ist. Als zus&auml;tzliche Anforderung muss die Hermitische Normal Form (HNF) des Gitters durch zwei ganze Zahlen repr&auml;sentierbar sein. <br/>
  In der Schl&uuml;sselerzeugungsphase, w&auml;hlt man ein zuf&auml;lliges Polynom v(x) mit Grad n-1. Aus dem Polynom l&auml;sst sich die Rotationsbasis V berechnen, die das zu verwendende Gitter beschreibt. Die Matrixdarstellung der HNF des Gitters, d.h. die Basisvektoren in den Spalten, m&uuml;ssen, abgesehen von der Spalte ganz links, der Identit&auml;tsmatrix gleichen. Diese Spalte hat als Eintr&auml;ge die Determinante des Gitters und alle Potenzen einer Wurzel r von f(x), modulo d. Als n&auml;chstes berechnet man die skalierte Inverse von v(x), d.h. ein Polynom w(x), so dass v(x)*w(x)=d mod f(x). Hier entspricht d der Determinante des Gitters. Die Rotationsbasis W, die ein Teil des privaten Schl&uuml;ssels ist, wird aus dem Vektor w(x) berechnet. Im Prinzip hat man nun alle ben&ouml;tigten Werte f&uuml;r ein Verschl&uuml;sselungsschema. Der &ouml;ffentliche Schl&uuml;ssel in diesem Fall ist die HNF des Gitters, bezeichnet mit B. Der private Schl&uuml;ssel besteht aus den Rotationsbasen V und W. Dieses Schema ist leider nur somewhat homomorph. Nach der Erl&auml;uterung der Ver- und Entschl&uuml;sselung folgt die Erkl&auml;rung, wie dies behoben werden kann. <br/>
  Die L&auml;nge einer Nachricht in diesem Schema ist nur ein einzelnes Bit. Um ein Bit zu verschl&uuml;sseln, generiert man einen zuf&auml;lligen n-dimensionalen Rausch-Vektor u mit Eintr&auml;gen in {-1,0,-1}. Dann berechnet man a=2u+b*e1 (e1 ist der Vektor (1,0,...,0)) und c = a mod B. Aufgrund der speziellen Form der HNF reduziert dies c = b + 2u(r) mod d, wobei u(x) das Polynom des Rausch-Vektors u ist. Um ein Chiffrat c zu entschl&uuml;sseln, berechnet man m = c mod V. Wiederum aufgrund der speziellen Form der HNF, reduziert sich dies auf b=(c*wi mod d) mod 2, wobei wi ein ungerader Term des Polynoms w(x) ist. Bezeichnen wir diesen Term mit w. <br/>
  Aufgrund der speziellen Form kann man, wie oben bereits bemerkt, den &ouml;ffentlichen Schl&uuml;ssel mit den ganzen Zahlen d und r und den privaten Schl&uuml;ssel mit der ganzen Zahl w bezeichnen. Dieses Schema ist nur somewhat homomorph, da es die Chiffrate nicht so aktualisieren kann, dass der Rausch-Vektor reduziert wird. Der Trick, dies doch zu tun, nennt sich Bootstrapping. Grob gesagt kann das Schema den eigenen Entschl&uuml;sselungsalgorithmus homomorph, zusammen mit einigen homomorphen Operationen, evaluieren. Das Schema kann einige Operationen evaluieren und dann das Chiffrat aktualisieren, so dass der Fehler im Chiffrat verringert wird. Der Verschl&uuml;sseler "startet" also die Entschl&uuml;sselung. Um dies zu erreichen, wird ein "Hinweis" auf die geheime, ganze Zahl w gegeben. Damit die Sicherheit nicht gef&auml;hrdet wird, wird eine große Anzahl Zahlen zu dem &ouml;ffentlichen Schl&uuml;ssel hinzugef&uuml;gt, von denen sich eine kleine Teilmenge zum geheimen w summiert. Um den Entschl&uuml;sselungsalgorithmus zu evaluieren, muss nat&uuml;rlich das Geheimnis implizit "bekannt" sind. Deshalb wird der Vektor, der diese kleine Teilmenge beschreibt, genauer ein Vektor, der eine 1 an der Position der Vektorelemente in der Teilmenge besitzt, verschl&uuml;sselt und dem &ouml;ffentlichen Schl&uuml;ssel hinzugef&uuml;gt. <br/>
  Jetzt, da das Geheimnis homomorph im &ouml;ffentlichen Schl&uuml;ssel verf&uuml;gbar ist, kann das Chiffrat aktualisiert werden und somit ist das Schema voll-homomorph geworden. Die Operationen f&uuml;r Multiplikation und Addition sind dieselben wie f&uuml;r das Chiffrat. Zus&auml;tzlich muss man das Chiffrat nach jeder Operation aktualisieren, damit gesichert ist, dass das Schema das Chiffrat noch korrekt entschl&uuml;sseln kann. </p>

  <h3 id="plugin">3) Plug-in-Benutzerhilfe</h3>

  <p>Um eines der drei Schemata f&uuml;r homomorphe Operationen zu verwenden, muss man sich zuerst ein Schl&uuml;sselpaar erzeugen. Dies kann auf der linken Bildschirmseite durchgef&uuml;hrt werden: Folgen Sie den Instruktionen, um sich ein Schl&uuml;sselpaar zu generieren oder zu w&auml;hlen. Der Schl&uuml;ssel kann außerdem f&uuml;r eine sp&auml;tere Benutzung gespeichert werden, wof&uuml;r das Plug-in einen Benutzernamen und ein Passwort ben&ouml;tigt. Der Schl&uuml;ssel wird dann in einer verschl&uuml;sselten Datei, zusammen mit einer Beschreibung, gespeichert. Dies ist n&uuml;tzlich, da beispielsweise eine Schl&uuml;sselerzeugung mit erh&ouml;hter Sicherheit f&uuml;r das Schema von Gentry und Halevi l&auml;nger dauert. <br/>
  Wenn ein Schl&uuml;sselpaar gew&auml;hlt wurde, muss man, im Falle des Schemas von Gentry und Halevi, einen Modulo f&uuml;r die Operationen w&auml;hlen. Je kleiner der Modulo gew&auml;hlt wird, desto schneller sind die Berechnungen. Danach w&auml;hlt man den ersten Operanden, der verschl&uuml;sselt werden soll. <br/>
  Um homomorphe Operationen durchf&uuml;hren zu k&ouml;nnen, werden zwei Operanden ben&ouml;tigt. Der erste Operand wird nur ein einziges Mal ben&ouml;tigt. Dann w&auml;hlt man auf der linken Seite die gew&uuml;nschte Operation. Anschließend wird nach dem zweiten Operand gefragt und die gew&auml;hlte Operation wird mit den beiden Operanden durchgef&uuml;hrt. Dies passiert homomorph und das Ergebnis-Chiffrat wird gezeigt. Unten auf dem Bildschirm werden die Operationen zus&auml;tzlich im Klartext durchgef&uuml;hrt, so dass der Nutzer dies verfolgen kann. <br/>
  F&uuml;r zus&auml;tzliche Operationen nutzt das Plug-in das zuvor berechnete Ergebnis anstatt des ersten Operanden. Wenn man verifizieren m&ouml;chte, ob das Chiffrat immer noch das Ergebnis verschl&uuml;sselt, w&auml;hlt man den "Ergebnis entschl&uuml;sseln"-Button auf der linken Seite. <br/>
  Um mit neuen Zahlen oder mit einem neuen Schl&uuml;ssel anzufangen, w&auml;hlt man den zugeh&ouml;rigen Button auf der linken Seite. </p>
</body>
</html>