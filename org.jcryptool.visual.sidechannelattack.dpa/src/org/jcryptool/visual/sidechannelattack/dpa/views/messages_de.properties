Constants_0=icons/explanation_4.jpg
Constants_1=icons/doubleAndAdd.jpg
Constants_10=Double and Add
Constants_100=x + 
Constants_101=\n   GF(
Constants_102=), a = 
Constants_103=, b = 
Constants_104=\n   Initial ECPoint P: 
Constants_105=\n   Parameter k: 
Constants_106=\n   k in Binary: 
Constants_107=\n\nb).Randomization:\n   
Constants_108=Random Factor r = 
Constants_109=\n   a' = a*r\u2074 = 
Constants_11=Note: the vulnerability to SPA attack can be solved by adding a dummy "add" operation in case of "0". It is named "Double and Add Always". However such countermeasure is still nonresistant to DPA attack, since the power consumption of "Double and Add always" method for each input looks same, but is slightly different. With statistic method like sampling analysis and differential analysis we can amplify the slight differences and recover the private key 'k'.\n\n Q = kP with Double and Add Always:\n   Q[0] = P;\n   for(i = n-2 down to 0){\n   Q[0] = 2Q[0]; Q[1] = Q[0] + P;\n   Q[0] = Q[d\u1D62]; \n\n}
Constants_110=, b' = b*r\u2076 = 
Constants_111=\n   P' = (r²*Xp, r³*Yp) = (
Constants_112=\n   EC': y² = x³ + a'x + b' 
Constants_113=\n            = x³ + 
Constants_114=x + 
Constants_115=. highest bit = 
Constants_116=Q = 2Q = 
Constants_117=P = (
Constants_118=Q = Q + P = 
Constants_119=The denominator 2Y\u2081 in ECDBL Formula is "0", please choose another point.
Constants_12=Parameter k Randomization:\nif the scalar multiplier k is randomized in each turn of execution, the attacker could not recover the private key per comparison the differences between the power traces analysis of "double and add" operations.\n\n The idea and principle are like so:\nFirst Choose a random factor in group [1,p-1], then a new randomized scalar multiplier k'=k+r*order[P] will be calculated,\nsince order[P]*P is the infinity point(0) of the chosen elliptic curve, we get:\n G'=(k+r*order[P])*P=k*P+r*(oder[P]*P)\n    =kP+r*0=G\n With such method even for the same private key k, the power traces are still ensured to be different. The relation between certain input parameter K and corresponding power trace during operation process will be broken.
Constants_120=Q[0] = 2Q[0] = 
Constants_121=Input:
Constants_122=Q = 2Q
Constants_123=Q = Q + P
Constants_124=Q[1]  = Q[0] + P = 
Constants_125=Q[0]' = 2Q[0]' = 
Constants_126=(P + R) = (
Constants_127=Q[1]'  = Q[0]' + (P + R) = 
Constants_128=P' = (
Constants_129=Q[1]'  = Q[0]' + P' = 
Constants_13=Double and Add always
Constants_130=Output:
Constants_131=Q' = k*(P+R) = Q + S = 
Constants_132=S = (x, y) then -S = (x, -y) = 
Constants_133=Q = Q' - S = Q' + (-S)
Constants_134=Q = (
Constants_135=Q' = (Xq*r²,Yq*r³) = 
Constants_136=\u0304
Constants_137=²
Constants_138=³
Constants_139=\u2081
Constants_14=Initial Point P Randomization:\nif the initial point P is randomized in each turn of execution, it is also difficult to recover the private key through analysis of the correlation between a certain kP and its power trace.\n\nBasic idea and principle:\nFirst we choose randomly another ECPoint R on the same EC which is different from the initial ECPoint. Then we calculate R+P = P' as the new initial ECPoint for EC cryptography. After "Double and Add Always" algorithm we get Q' = kP' = k( P + R ) = kP + kR = Q + kR as the result. \nAnd for an ECPoint satisfies S = (x,y) then -S = (x, -y), thus Q = Q' - kR = Q' + (-kR), with this method we can calculate the result Q but concealing the real initial point P, in this way the correlation between power traces and the initial input P is also concealed.
Constants_140=\u2074
Constants_141=\u2076
Constants_142=\u2082
Constants_143=\u1D62
Constants_144=\u2074
Constants_145=\u2076
Constants_146=\u207B
Constants_147=Xq = 
Constants_148=Yq = 
Constants_149=org.jcryptool.visual.sidechannelattack.dpa.dpaview
Constants_15=Isomorphic Curve Randomization:\nwe use a random isomorphic curve to the original curve, and after "Double and Add always" we recover the original result Q from Q'. The random isomorphic curve could also be understand as a DPA countermeasure with the method of randomizing the initial point P.\n\nIdea and process:\nFirst we choose randomly a number r in prime field [1, p-1], and then we calculate a' = r\u2074a, b' = r\u2076b P' = (r²Xp, r³Yp). With new a', b', P' we get a new isomorphic curve: E': y² = x³ + a'x + b' After that we compute Q' = kP' on the new isomorphic curve. Q' = (Xq', Yq'). Finally we recover Q =(r\u207B²Xq',r\u207B³Yq'). Actually the method "isomorphic curve" breaks the correlation between ECPoint and power traces of different operations through randomizing the initial point.
Constants_16=Randomize Parameter k
Constants_17=Randomize initial ECPoint P
Constants_18=Random Isomorphic Curve
Constants_19=1. Q = KP at step j the processed point Q depends only on the first bits (kn-2,kn-3; : : : ; kj ) of K.\n\n2. Power consumption will be correlated to specific bit of Q, no correlation will be observed with a point not computed.\n\n3. The 2th most significant bit kn-2 of K can be recovered by computing the correlation between power consumption and any specific bit of the binary representation of 6P.\n\n 4. If kn-1 = 1, 6P is computed as Q[0] = 2*3P = 6P, otherwise by kn-1 = 0, 2*2P will be carried out during the Double operation.\n\n5. We gather many power consumption of computing 6P, and let si be any specific bit of 6P. We use the correlation function: g(t) = Power(si = 0) - Power(si = 1).\n\n6. If 6P is related to simulated correlation function g(t), a peak is observed corresponding to the computation of 6P, otherwise if there is no peak, the second significant bit is 0.\n\n7. The following bits kn-3, kn-4,... kj of K can be recursively recovered in the same way.\n\n8. The countermeasures against DPA are randomizing either the Initial Point P or the scalar multiplier K.
Constants_2=icons/double2.jpg
Constants_20=Double and Add Always
Constants_21=DPA against Double and Add:
Constants_22=choose the parameter a of the EC here
Constants_23=choose the parameter b of the EC here
Constants_24=order of the selected EC, that means the number of ECPoints on the curve plus the infinity point O
Constants_25=select the scalar multiplier k for Q = kP here
Constants_26=choose an ECPoint P as initial Point of ECC, except the infinity point O 
Constants_27=Execute
Constants_28=the order of selected initial point P, which means the minimum number k in GF(p) which satisfied kP = infinity point
Constants_29=choose the prime field GF(p) here
Constants_3=icons/doubleAndAdd_0.jpg
Constants_30=1. Q = KP at step j the processed point Q depends only on the first bits (kn-2,kn-3; : : : ; kj ) of K.\n\n2. Power consumption will be correlated to specific bit of Q, no correlation will be observed with a point not computed.\n\n3. The 2th most significant bit kn-2 of K can be recovered by computing the correlation between power consumption and any specific bit of the binary representation of 6P.\n\n 4. If kn-1 = 1, 6P is computed as Q[0] = 2*3P = 6P, otherwise by kn-1 = 0, 2*2P will be carried out during the Double operation.\n\n5. We gather many power consumption of computing 6P, and let si be any specific bit of 6P. We use the correlation function: g(t) = Power(si = 0) - Power(si = 1)\n\n6. If 6P is related to simulated correlation function g(t), a peak is observed corresponding to the computation of 6P, otherwise if there is no peak, the second significant bit is 0.\n\n7. The following bits kn-3, kn-4,... kj of K can be recursively recovered in the same way.
Constants_31=Secure countermeasures against SPA/DPA:
Constants_32=\ \ \ Q = 
Constants_33=a =
Constants_34=b = 
Constants_35=the EC has been selected with parameter a, b and GF(p)
Constants_36=Q[0]' = 2Q[0]'
Constants_37=Q[1]' = Q[0]' + P
Constants_38=k in binary form: 
Constants_39=Parameters
Constants_4=org.jcryptool.visual.sidechannelattack.dpaview
Constants_40=Parameter of Countermeasures
Constants_41=Part 4. Double and Add (from left highest to right lowest valuable bit)
Constants_42=Round Counter(left to right)
Constants_43=Result after Double
Constants_44=Result after Add
Constants_45=Choose a Point (no infinity point):
Constants_46=GF(p) =
Constants_47=y² = x³ + 
Constants_48=x + 
Constants_49=, GF(
Constants_5=DPA against ECC
Constants_50=a, b must be set in GF(p).
Constants_51=4a³ + 27b² = 0. Change please.
Constants_52=Give correct number please.
Constants_53=a, b must be set in GF(p).
Constants_54=4a³ + 27b² = 0. Change please.
Constants_55=Order of selected ECPoint: 
Constants_56=Order of Curve: 
Constants_57=ECPoint(P): 
Constants_58=Parameter k: 
Constants_59=\ (dec.)
Constants_6=Information
Constants_60=Binary: 
Constants_61=\ (bin.)
Constants_62=Process: 
Constants_63=Input:
Constants_64=Q[0] = 2Q[0]
Constants_65=Q[1] = Q[0] + P
Constants_66=1. Countermeasure against DPA:\n   (Parameter k Randomization)\n\n
Constants_67=a).Original Input:\n   Elliptic Curve: y² = x³ + 
Constants_68=\n   GF(
Constants_69=), a = 
Constants_7=Note: the scalar multiplication operation of ECCPoints above the elliptic curve is normally realized with "Double and Add" algorithm, the following introduced algorithm is based on "Double and Add Always", which is proved to be secure to SPA but still insecure to DPA.\nThe concrete attack process will be given on the right side in visual form and after all the corresponding countermeasures. 
Constants_70=, b = 
Constants_71=\n   Initial ECPoint P: 
Constants_72=\n   Parameter k: 
Constants_73=\n   k in Binary: 
Constants_74=\n\nb).Randomization:\n   Random Factor r: 
Constants_75=\n   Order of P o(P): 
Constants_76=\n   k' = k + o(P)*r = 
Constants_77=\n   k' in Binary: 
Constants_78=Random ECPoint R: (
Constants_79=S = k*R = 
Constants_8=Part 2. Explanation of Algorithm: 
Constants_80=R = 
Constants_81=2. Countermeasure against DPA:\n   (Initial Point P Randomization)\n\n
Constants_82=a).Original Input:\n   Elliptic Curve: y² = x³ + 
Constants_83=x + 
Constants_84=\n   GF(
Constants_85=), a = 
Constants_86=, b = 
Constants_87=\n   Initial ECPoint P: 
Constants_88=\n   Parameter k: 
Constants_89=\n   k in Binary: 
Constants_9=Insecurity of "Double and Add" to SPA:\nsince the private key can be recovered through comparison the difference of power traces between ECAdd and ECDouble operations, the original "Double and Add" algorithm is insecure to both SPA and DPA.\n\nInput:\n ECPoint P;\n scalar parameter k;\n\nOutput:\n Q = kP;\n\nProcess:\n Q = P;\n for(i = n-2 down to 0){\n Q = 2Q;\n if(di == 1)\n Q = Q + P; }
Constants_90=\n\nb).Randomization:\n   
Constants_91=Random ECPoint R: (
Constants_92=\n   P + R = 
Constants_93=\n   S = k*R = 
Constants_94=R = 
Constants_95=\n   Q' = k*(P+R) = Q + S
Constants_96=\n   if S = (x, y) then -S = (x, -y)
Constants_97=\n   Q = Q' - S = Q' + (-S)
Constants_98=3. Countermeasure against DPA:\n   (Isomorphic Curve Random.)\n\n
Constants_99=a).Original Input:\n   Elliptic Curve: y² = x³ + 
mode = Modus:
parameter = Parameter der EC:
points = Punkte auf der EC:
order_curve = Kurvenordnung
curve = Kurve: